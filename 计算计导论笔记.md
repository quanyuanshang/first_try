# 计算机导论
## 计算机的早期历史
1. 算盘
2. 步进计算器（能做加减乘除）
3. 差分机
    > - 分析机
4. 打孔机器
5. 继电器
6. 真空管
    >- less wear(vacum tubes) 
    >- 被用于巨人号
    > - ENIAC
    
7. 晶体管
    > - 控制线路的开与关
    > - 两个electrides电极，电极之间半导体连接（硅）
    > - 体积更小，成本更低，速度快
    > - 用两种状态传达信息
    >>  电流流过 true 1
    >>  布尔代数系统 not and or

## 布尔逻辑和逻辑门
1. 逻辑门(叫做门是因为它能控制电流的1流向)
> - and门
>> 只有两个输入是t，输出才会是t==两个晶体管都打开了才会有电流流通
> - not gate
>> 输入是off，输出是on；输入是on，输出是off；
> - or gate
>> 两个输出，有一个是t，输出就是t
>> 两个晶体管是并联的
> - xor gate![屏幕截图 2024-08-21 194045](/assets/屏幕截图%202024-08-21%20194045.png)
>> 两个输入必须不要一样![屏幕截图 2024-08-21 193856](/assets/屏幕截图%202024-08-21%20193856.png)

## 二进制  
1. 表示浮点数的方法
> sign+指数+有效位数（科学计数法）
2. ASCII码
> 剩下里空的没被定下的各个国家给自己用
3. UNCODE
> 统一编码 16位 甚至放下了数学符号和emoji

## 算术逻辑
1. ALU（V）
> 计算
>> 半加器 xor+and
>> 全加器 ![alt text](image.png)八位二进制计算器![alt text](image-1.png)
>> 无乘法 只是重复做加法

> 逻辑单位
>> 逻辑门的组合

> 四位的操作代码告诉ALU做啥，输出结果一般是8位。

>标志
>> 进位
>> 0
>> 负

## 寄存器 内存
1. AND-OR锁存器
> ![zhienngcun0demen](image-2.png)这样只能保存1
> ![alt text](image-3.png)这样只能保存0
> ![alt text](image-4.png)当设置与复位都是0，那么就会输入最后放入的内容

2. 门锁
> 一个数据输入线 一个允许启用内存线 ，只有当允许写入开启才会存，这时关闭允许线也会保存之前输入的1 or 0（只能存一位）
![alt text](image-5.png)

3.寄存器
>把8 16 32 64位门锁作为一组，叫做寄存器
![alt text](image-6.png)
但是连接这些门锁要很多数据线，解决方法：矩阵
>> ![16*16](image-7.png)需要开启某个锁存器，利用and门，把相应的行线和列线都打开（这个地址再用2个4bit存，用2个多路复用器去到对应的位置）才能让and门输出1然后锁存器开启，这样除了行列的线只需要再加上1条reading 1条允许读入线就可以
>>> ![alt text](image-8.png)
![alt text](image-9.png)8个单元组合作为1位
>>>> ![alt text](image-10.png)8个单元再组合

> ram:可以随时访问任何位置
    DATA的前四位是操作码，后四位指向一个内存地址/寄存器

## 中央处理器
1.  寄存器
- 指令地址寄存器
> 连接到RAM
> 取指令阶段：寄存器的值对应RAM里的地址值，再将地址值对应的DATA给到指令寄存器
- 指令寄存器
> 解码阶段：得到指令之后去检查指令
> 执行阶段：解码电路连一根允许写入线到A，LOAD_A指令将数据放入寄存器A。
如果是ADD指令，就还需要再加入ALU，将计算得来的结果暂存于control unit之后再给到相应的寄存器

2. 时钟
> 控制速度（Hz 1周期）
> 超频 可能导致电脑烧坏；运行性能较低的程序时，降频反而会给电脑省电

3. CPU和RAM之间有一些数据线和地址线的连接
![alt text](image-12.png)

## 指令和程序

1. JUMP
- 地址寄存器跳转到JUMP后面的数字

2. JUMP negative
- 确保jump是有条件的

3. 4字节不够长 放不下足够的寄存器和指令
- 解决：32字节 64字节
- 可变指令长度 立即读取值，指令就可以是任意长度

## 高级CPU设计
现代CPU有上千条指令和各种复杂的电路
-  如何快速传递数据给CPU：
一、优化1个指令流的吞吐量
> 1. 在CPU里加一点RAM（cache缓存，比较小KB，而正版内存有GB），RAM直接给缓存一批数据![alt text](image-13.png),因为离得近，CPU就不用等了。想要的数据在cache里面就是cache hit（miss）。
>> cache也可以作为临时空间帮助长复杂运算.CPU把结果先暂时存在cache，这些比内存多出来的数据叫做dirty bit。当缓存满了而CPU又要用到缓存时，就会检查脏位，把数据写回内存。

2. 指令流水线
> 并行：取 解码 执行（用到CPU不同地方，所以不同指令可以重叠进行![alt text](image-14.png)）
>> 同时进行的任务需要搞清楚任务依赖性(乱序执行)

> 处理JUMP指令带来的空挡 --推测执行：（要等JUMP结果出现），相当于在一个岔路，CPU推测哪个指令有可能并放进流水线，猜错了就清空流水线。
>> 减少清空次数：分支预测

>一次性处理多条指令（让闲置的ALU工作）![alt text](image-15.png)

二、同时处理多个指令流
> 1. 多核处理器：![alt text](image-16.png)
      一个CPU芯片里，有多个独立处理单元，像是有多个CPU互通
2. 多个CPU（2-4）
--------------------超级计算机

## 早期的编程方式
1. 插拔线控制面板
2. 穿孔纸卡存储程序计算机
> 冯诺依曼结构（含有ALU的处理器+数据寄存器+指令地址寄存器+内存）
>> 还是读取打孔纸让数据进入计算机
>> 将结果以孔的形式打印在纸上
3. 面板编程
> 开关与按钮，指示灯表示函数的状态和内存中的值

## 编程语言发展历史

1. 伪代码，用0110写指令
2. 助记符
3. 汇编器让指令从LOAD_4变成二进制
   - 可以自动分析JUMP地址

4. 编译器：将代码转换为机器码

## 编程原理语句与函数

1. 语法

   - 变量

   - control flow statement控制流语句

​		if while 

2. 函数（打包的方法）

3. library（库）前人帮忙写好的